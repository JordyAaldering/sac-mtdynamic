use Array: all;
use Benchmarking: all;
use CommandLine: all;
use StdIO: all;

inline
float maximum(float[d:shp] x)
{
    return with {
        (0*shp <= iv < shp): x[iv];
    }: fold(max, 0.0);
}

inline
float[m,n] stabilise(float[m,n] x)
{
    return { [i] -> x[i] - maximum(x[i]) };
}

inline
float[d:shp] exp(float[d:shp] x)
{
    return { iv -> Math::exp(x[iv]) };
}

inline
float[m,n] matmulT(float[m,k] A, float[n,k] B)
{
    return { [i,j] -> with {
                        ([0] <= [p] < [k]): A[i,p] * B[j,p];
                      }: fold(+, 0.0)
           | [i,j] < [m,n]};
}

inline
float[m,n] scale(float[m,n] x)
{
    return { [i] -> x[i] / with {
                             ([0] <= [j] < [n]): x[i, j];
                           }: fold(+, 0.0) };
}

inline
float[Nd,d,d] FlashAttention(float[Nd,d,d] Q, float[N,d] K, float[N,d] V)
    | (Nd == N / d)
{
    Vt = { [i, j] -> V[j, i] };
    return { [i] -> matmulT(scale(exp(stabilise(matmulT(Q[i], K)))), Vt) };
}

float L2(float[*] x)
{
    return Math::sqrt(sum(x * x));
}

int main()
{
    d = String::toi(argv(argc() - 2));
    N = String::toi(argv(argc() - 1));
    fprintf(stderr, "Running with d = %d, N = %d\n", d, N);

    Q = { [i, j, k] -> tof(1) / (tof(1) + tof(i)) | [i, j, k] < [N / d, d, d] };
    K = { [i, j] -> tof(1) | [i, j] < [N, d] };
    V = { [i, j] -> tof(1) | [i, j] < [N, d] };

    itime = getInterval("time", 1);
    start(itime);

    O = FlashAttention(Q, K, V);

    end(itime);
    time, unit = returnResultUnit(itime);

    fprintf(stderr, "L2 norm of output is %lf, should be %lf\n",
                    L2(O), Math::sqrt(tof(d * N)));
    fprintf(stderr, "This took %f%s.\n", time, unit);
    printf("%f\n", 4d * tod(N) * tod(N) * (tod(d) + 1d) / time / 1e9, unit);

    return 0;
}
